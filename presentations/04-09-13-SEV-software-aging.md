# Software Aging
## Author David L. Parnas
### Presenter Evan Purkhiser


(Spoiler: It's pretty great)


# David L. Parnas
![Davic Lorge Parnas](http://i.imgur.com/3jfGtzd.jpg)


## Who is he?

 * 72 years old, born in February of 1941
 * Ph.D in electrical engineering from Carnegie Mellon
 * Has received various different awards for his papers
 * Primary work on "Modular design" and "Information hiding"
 * Involved in technical activism and a push for the professionalization of
   software engineering


Software is much like a human being, it **will** age over time


# Why?


## Two reasons...

 1. Decaying source code / product (Lack of movement)
 2. Poorly understood source code changes (Ignorant surgery)


After many such changes, the original designers no longer understand the
product. Those who made the changes never did. In other words, _nobody
understand the modified product_


<small>(aside)</small>
### Software Aging `!=` Software buggy-ness

However, the software buggy-ness may be due in part to the poorly understood
changes made to the software


# What happens?


## Three main things


## 1
### Software gets fat

Too keep up with demand for new features, code is piled into the project without
any thought or planning

Each new feature takes longer and longer and customers quickly lose interest in
the product


## 2
### Performance hits

Customers must upgrade their computers to achieve acceptable response times


## 3
### Loss in reliability

Errors will be introduced

Attempting to fix the errors will just result in more errors


# Prevention

Whilst it's not possible to stop software from aging, it is possible to slow
down it's aging process


## Designing for change

 * Attempt to predict how the software will change
 * Apply design principles to assist in this.
   * Information Hiding
   * Abstraction
   * Separation of Concerns
   * Data Hiding
   * Object Oriented
 * Organize for items that are likely to change


## Why is this so hard?


 * Impatience leads to denial
 * Only thinking about what it needs to do _now_
 * Not enough well designed programs to copy
 * Design principles `!=` Programming language
 * Little communication as a whole for programmers <small>(Is this still a
   problem?)</small>
 * Too much preaching to the choir


## Documentation


## Which also appears to be pretty hard...


 * Documentation is often times ignored
 * If it is written, it's poorly done and fragmented
 * Hard to find or understand by future developers
 * Becomes out of sync with the software and is ignored
 * Takes _too much time_ or isn't _very exciting_


## Code & Design peer reviews


## And _of course_, once again...


## This is hard...

 * Education neglected the need for reviews
 * No precise design documentation makes review hard
 * No other developers to review
 * Time constraints
 * Programmers can be defensive about their code


Get more serious about these things!


## Aging will still happen. You _cannot predict the future_!


# It's already old. Now what?


# Planing ahead


# Taking Action


## Some Questions
